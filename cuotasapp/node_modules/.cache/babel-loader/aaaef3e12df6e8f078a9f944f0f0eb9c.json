{"ast":null,"code":"'use strict';\n\nvar compileSchema = require('./compile'),\n    resolve = require('./compile/resolve'),\n    Cache = require('./cache'),\n    SchemaObject = require('./compile/schema_obj'),\n    stableStringify = require('json-stable-stringify'),\n    formats = require('./compile/formats'),\n    rules = require('./compile/rules'),\n    v5 = require('./v5'),\n    util = require('./compile/util'),\n    async = require('./async'),\n    co = require('co');\n\nmodule.exports = Ajv;\nAjv.prototype.compileAsync = async.compile;\n\nvar customKeyword = require('./keyword');\n\nAjv.prototype.addKeyword = customKeyword.add;\nAjv.prototype.getKeyword = customKeyword.get;\nAjv.prototype.removeKeyword = customKeyword.remove;\nAjv.ValidationError = require('./compile/validation_error');\nvar META_SCHEMA_ID = 'http://json-schema.org/draft-04/schema';\nvar SCHEMA_URI_FORMAT = /^(?:(?:[a-z][a-z0-9+-.]*:)?\\/\\/)?[^\\s]*$/i;\n\nfunction SCHEMA_URI_FORMAT_FUNC(str) {\n  return SCHEMA_URI_FORMAT.test(str);\n}\n\nvar META_IGNORE_OPTIONS = ['removeAdditional', 'useDefaults', 'coerceTypes'];\n/**\n * Creates validator instance.\n * Usage: `Ajv(opts)`\n * @param {Object} opts optional options\n * @return {Object} ajv instance\n */\n\nfunction Ajv(opts) {\n  if (!(this instanceof Ajv)) return new Ajv(opts);\n  var self = this;\n  opts = this._opts = util.copy(opts) || {};\n  this._schemas = {};\n  this._refs = {};\n  this._fragments = {};\n  this._formats = formats(opts.format);\n  this._cache = opts.cache || new Cache();\n  this._loadingSchemas = {};\n  this._compilations = [];\n  this.RULES = rules(); // this is done on purpose, so that methods are bound to the instance\n  // (without using bind) so that they can be used without the instance\n\n  this.validate = validate;\n  this.compile = compile;\n  this.addSchema = addSchema;\n  this.addMetaSchema = addMetaSchema;\n  this.validateSchema = validateSchema;\n  this.getSchema = getSchema;\n  this.removeSchema = removeSchema;\n  this.addFormat = addFormat;\n  this.errorsText = errorsText;\n  this._addSchema = _addSchema;\n  this._compile = _compile;\n  opts.loopRequired = opts.loopRequired || Infinity;\n  if (opts.async || opts.transpile) async.setup(opts);\n  if (opts.beautify === true) opts.beautify = {\n    indent_size: 2\n  };\n  if (opts.errorDataPath == 'property') opts._errorDataPathProperty = true;\n  this._metaOpts = getMetaSchemaOptions();\n  if (opts.formats) addInitialFormats();\n  addDraft4MetaSchema();\n  if (opts.v5) v5.enable(this);\n  if (typeof opts.meta == 'object') addMetaSchema(opts.meta);\n  addInitialSchemas();\n  /**\n   * Validate data using schema\n   * Schema will be compiled and cached (using serialized JSON as key. [json-stable-stringify](https://github.com/substack/json-stable-stringify) is used to serialize.\n   * @param  {String|Object} schemaKeyRef key, ref or schema object\n   * @param  {Any} data to be validated\n   * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).\n   */\n\n  function validate(schemaKeyRef, data) {\n    var v;\n\n    if (typeof schemaKeyRef == 'string') {\n      v = getSchema(schemaKeyRef);\n      if (!v) throw new Error('no schema with key or ref \"' + schemaKeyRef + '\"');\n    } else {\n      var schemaObj = _addSchema(schemaKeyRef);\n\n      v = schemaObj.validate || _compile(schemaObj);\n    }\n\n    var valid = v(data);\n    if (v.$async === true) return self._opts.async == '*' ? co(valid) : valid;\n    self.errors = v.errors;\n    return valid;\n  }\n  /**\n   * Create validating function for passed schema.\n   * @param  {Object} schema schema object\n   * @param  {Boolean} _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.\n   * @return {Function} validating function\n   */\n\n\n  function compile(schema, _meta) {\n    var schemaObj = _addSchema(schema, undefined, _meta);\n\n    return schemaObj.validate || _compile(schemaObj);\n  }\n  /**\n   * Adds schema to the instance.\n   * @param {Object|Array} schema schema or array of schemas. If array is passed, `key` and other parameters will be ignored.\n   * @param {String} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n   * @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.\n   * @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n   */\n\n\n  function addSchema(schema, key, _skipValidation, _meta) {\n    if (Array.isArray(schema)) {\n      for (var i = 0; i < schema.length; i++) addSchema(schema[i], undefined, _skipValidation, _meta);\n\n      return;\n    } // can key/id have # inside?\n\n\n    key = resolve.normalizeId(key || schema.id);\n    checkUnique(key);\n    self._schemas[key] = _addSchema(schema, _skipValidation, _meta, true);\n  }\n  /**\n   * Add schema that will be used to validate other schemas\n   * options in META_IGNORE_OPTIONS are alway set to false\n   * @param {Object} schema schema object\n   * @param {String} key optional schema key\n   * @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema\n   */\n\n\n  function addMetaSchema(schema, key, skipValidation) {\n    addSchema(schema, key, skipValidation, true);\n  }\n  /**\n   * Validate schema\n   * @param {Object} schema schema to validate\n   * @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid\n   * @return {Boolean} true if schema is valid\n   */\n\n\n  function validateSchema(schema, throwOrLogError) {\n    var $schema = schema.$schema || self._opts.defaultMeta || defaultMeta();\n    var currentUriFormat = self._formats.uri;\n    self._formats.uri = typeof currentUriFormat == 'function' ? SCHEMA_URI_FORMAT_FUNC : SCHEMA_URI_FORMAT;\n    var valid;\n\n    try {\n      valid = validate($schema, schema);\n    } finally {\n      self._formats.uri = currentUriFormat;\n    }\n\n    if (!valid && throwOrLogError) {\n      var message = 'schema is invalid: ' + errorsText();\n      if (self._opts.validateSchema == 'log') console.error(message);else throw new Error(message);\n    }\n\n    return valid;\n  }\n\n  function defaultMeta() {\n    var meta = self._opts.meta;\n    self._opts.defaultMeta = typeof meta == 'object' ? meta.id || meta : self._opts.v5 ? v5.META_SCHEMA_ID : META_SCHEMA_ID;\n    return self._opts.defaultMeta;\n  }\n  /**\n   * Get compiled schema from the instance by `key` or `ref`.\n   * @param  {String} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).\n   * @return {Function} schema validating function (with property `schema`).\n   */\n\n\n  function getSchema(keyRef) {\n    var schemaObj = _getSchemaObj(keyRef);\n\n    switch (typeof schemaObj) {\n      case 'object':\n        return schemaObj.validate || _compile(schemaObj);\n\n      case 'string':\n        return getSchema(schemaObj);\n\n      case 'undefined':\n        return _getSchemaFragment(keyRef);\n    }\n  }\n\n  function _getSchemaFragment(ref) {\n    var res = resolve.schema.call(self, {\n      schema: {}\n    }, ref);\n\n    if (res) {\n      var schema = res.schema,\n          root = res.root,\n          baseId = res.baseId;\n      var v = compileSchema.call(self, schema, root, undefined, baseId);\n      self._fragments[ref] = new SchemaObject({\n        ref: ref,\n        fragment: true,\n        schema: schema,\n        root: root,\n        baseId: baseId,\n        validate: v\n      });\n      return v;\n    }\n  }\n\n  function _getSchemaObj(keyRef) {\n    keyRef = resolve.normalizeId(keyRef);\n    return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];\n  }\n  /**\n   * Remove cached schema(s).\n   * If no parameter is passed all schemas but meta-schemas are removed.\n   * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n   * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n   * @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object\n   */\n\n\n  function removeSchema(schemaKeyRef) {\n    if (schemaKeyRef instanceof RegExp) {\n      _removeAllSchemas(self._schemas, schemaKeyRef);\n\n      _removeAllSchemas(self._refs, schemaKeyRef);\n\n      return;\n    }\n\n    switch (typeof schemaKeyRef) {\n      case 'undefined':\n        _removeAllSchemas(self._schemas);\n\n        _removeAllSchemas(self._refs);\n\n        self._cache.clear();\n\n        return;\n\n      case 'string':\n        var schemaObj = _getSchemaObj(schemaKeyRef);\n\n        if (schemaObj) self._cache.del(schemaObj.jsonStr);\n        delete self._schemas[schemaKeyRef];\n        delete self._refs[schemaKeyRef];\n        return;\n\n      case 'object':\n        var jsonStr = stableStringify(schemaKeyRef);\n\n        self._cache.del(jsonStr);\n\n        var id = schemaKeyRef.id;\n\n        if (id) {\n          id = resolve.normalizeId(id);\n          delete self._schemas[id];\n          delete self._refs[id];\n        }\n\n    }\n  }\n\n  function _removeAllSchemas(schemas, regex) {\n    for (var keyRef in schemas) {\n      var schemaObj = schemas[keyRef];\n\n      if (!schemaObj.meta && (!regex || regex.test(keyRef))) {\n        self._cache.del(schemaObj.jsonStr);\n\n        delete schemas[keyRef];\n      }\n    }\n  }\n\n  function _addSchema(schema, skipValidation, meta, shouldAddSchema) {\n    if (typeof schema != 'object') throw new Error('schema should be object');\n    var jsonStr = stableStringify(schema);\n\n    var cached = self._cache.get(jsonStr);\n\n    if (cached) return cached;\n    shouldAddSchema = shouldAddSchema || self._opts.addUsedSchema !== false;\n    var id = resolve.normalizeId(schema.id);\n    if (id && shouldAddSchema) checkUnique(id);\n    var willValidate = self._opts.validateSchema !== false && !skipValidation;\n    var recursiveMeta;\n    if (willValidate && !(recursiveMeta = schema.id && schema.id == schema.$schema)) validateSchema(schema, true);\n    var localRefs = resolve.ids.call(self, schema);\n    var schemaObj = new SchemaObject({\n      id: id,\n      schema: schema,\n      localRefs: localRefs,\n      jsonStr: jsonStr,\n      meta: meta\n    });\n    if (id[0] != '#' && shouldAddSchema) self._refs[id] = schemaObj;\n\n    self._cache.put(jsonStr, schemaObj);\n\n    if (willValidate && recursiveMeta) validateSchema(schema, true);\n    return schemaObj;\n  }\n\n  function _compile(schemaObj, root) {\n    if (schemaObj.compiling) {\n      schemaObj.validate = callValidate;\n      callValidate.schema = schemaObj.schema;\n      callValidate.errors = null;\n      callValidate.root = root ? root : callValidate;\n      if (schemaObj.schema.$async === true) callValidate.$async = true;\n      return callValidate;\n    }\n\n    schemaObj.compiling = true;\n    var currentOpts;\n\n    if (schemaObj.meta) {\n      currentOpts = self._opts;\n      self._opts = self._metaOpts;\n    }\n\n    var v;\n\n    try {\n      v = compileSchema.call(self, schemaObj.schema, root, schemaObj.localRefs);\n    } finally {\n      schemaObj.compiling = false;\n      if (schemaObj.meta) self._opts = currentOpts;\n    }\n\n    schemaObj.validate = v;\n    schemaObj.refs = v.refs;\n    schemaObj.refVal = v.refVal;\n    schemaObj.root = v.root;\n    return v;\n\n    function callValidate() {\n      var _validate = schemaObj.validate;\n\n      var result = _validate.apply(null, arguments);\n\n      callValidate.errors = _validate.errors;\n      return result;\n    }\n  }\n  /**\n   * Convert array of error message objects to string\n   * @param  {Array<Object>} errors optional array of validation errors, if not passed errors from the instance are used.\n   * @param  {Object} options optional options with properties `separator` and `dataVar`.\n   * @return {String} human readable string with all errors descriptions\n   */\n\n\n  function errorsText(errors, options) {\n    errors = errors || self.errors;\n    if (!errors) return 'No errors';\n    options = options || {};\n    var separator = options.separator === undefined ? ', ' : options.separator;\n    var dataVar = options.dataVar === undefined ? 'data' : options.dataVar;\n    var text = '';\n\n    for (var i = 0; i < errors.length; i++) {\n      var e = errors[i];\n      if (e) text += dataVar + e.dataPath + ' ' + e.message + separator;\n    }\n\n    return text.slice(0, -separator.length);\n  }\n  /**\n   * Add custom format\n   * @param {String} name format name\n   * @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)\n   */\n\n\n  function addFormat(name, format) {\n    if (typeof format == 'string') format = new RegExp(format);\n    self._formats[name] = format;\n  }\n\n  function addDraft4MetaSchema() {\n    if (self._opts.meta !== false) {\n      var metaSchema = require('./refs/json-schema-draft-04.json');\n\n      addMetaSchema(metaSchema, META_SCHEMA_ID, true);\n      self._refs['http://json-schema.org/schema'] = META_SCHEMA_ID;\n    }\n  }\n\n  function addInitialSchemas() {\n    var optsSchemas = self._opts.schemas;\n    if (!optsSchemas) return;\n    if (Array.isArray(optsSchemas)) addSchema(optsSchemas);else for (var key in optsSchemas) addSchema(optsSchemas[key], key);\n  }\n\n  function addInitialFormats() {\n    for (var name in self._opts.formats) {\n      var format = self._opts.formats[name];\n      addFormat(name, format);\n    }\n  }\n\n  function checkUnique(id) {\n    if (self._schemas[id] || self._refs[id]) throw new Error('schema with key or id \"' + id + '\" already exists');\n  }\n\n  function getMetaSchemaOptions() {\n    var metaOpts = util.copy(self._opts);\n\n    for (var i = 0; i < META_IGNORE_OPTIONS.length; i++) delete metaOpts[META_IGNORE_OPTIONS[i]];\n\n    return metaOpts;\n  }\n}","map":{"version":3,"sources":["C:/Users/juanm/Documents/Proyecto_web/ProyectoFinal-IAW/cuotasapp/node_modules/mercadopago/node_modules/ajv/lib/ajv.js"],"names":["compileSchema","require","resolve","Cache","SchemaObject","stableStringify","formats","rules","v5","util","async","co","module","exports","Ajv","prototype","compileAsync","compile","customKeyword","addKeyword","add","getKeyword","get","removeKeyword","remove","ValidationError","META_SCHEMA_ID","SCHEMA_URI_FORMAT","SCHEMA_URI_FORMAT_FUNC","str","test","META_IGNORE_OPTIONS","opts","self","_opts","copy","_schemas","_refs","_fragments","_formats","format","_cache","cache","_loadingSchemas","_compilations","RULES","validate","addSchema","addMetaSchema","validateSchema","getSchema","removeSchema","addFormat","errorsText","_addSchema","_compile","loopRequired","Infinity","transpile","setup","beautify","indent_size","errorDataPath","_errorDataPathProperty","_metaOpts","getMetaSchemaOptions","addInitialFormats","addDraft4MetaSchema","enable","meta","addInitialSchemas","schemaKeyRef","data","v","Error","schemaObj","valid","$async","errors","schema","_meta","undefined","key","_skipValidation","Array","isArray","i","length","normalizeId","id","checkUnique","skipValidation","throwOrLogError","$schema","defaultMeta","currentUriFormat","uri","message","console","error","keyRef","_getSchemaObj","_getSchemaFragment","ref","res","call","root","baseId","fragment","RegExp","_removeAllSchemas","clear","del","jsonStr","schemas","regex","shouldAddSchema","cached","addUsedSchema","willValidate","recursiveMeta","localRefs","ids","put","compiling","callValidate","currentOpts","refs","refVal","_validate","result","apply","arguments","options","separator","dataVar","text","e","dataPath","slice","name","metaSchema","optsSchemas","metaOpts"],"mappings":"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","sourcesContent":["'use strict';\n\nvar compileSchema = require('./compile')\n  , resolve = require('./compile/resolve')\n  , Cache = require('./cache')\n  , SchemaObject = require('./compile/schema_obj')\n  , stableStringify = require('json-stable-stringify')\n  , formats = require('./compile/formats')\n  , rules = require('./compile/rules')\n  , v5 = require('./v5')\n  , util = require('./compile/util')\n  , async = require('./async')\n  , co = require('co');\n\nmodule.exports = Ajv;\n\nAjv.prototype.compileAsync = async.compile;\n\nvar customKeyword = require('./keyword');\nAjv.prototype.addKeyword = customKeyword.add;\nAjv.prototype.getKeyword = customKeyword.get;\nAjv.prototype.removeKeyword = customKeyword.remove;\nAjv.ValidationError = require('./compile/validation_error');\n\nvar META_SCHEMA_ID = 'http://json-schema.org/draft-04/schema';\nvar SCHEMA_URI_FORMAT = /^(?:(?:[a-z][a-z0-9+-.]*:)?\\/\\/)?[^\\s]*$/i;\nfunction SCHEMA_URI_FORMAT_FUNC(str) {\n  return SCHEMA_URI_FORMAT.test(str);\n}\n\nvar META_IGNORE_OPTIONS = [ 'removeAdditional', 'useDefaults', 'coerceTypes' ];\n\n/**\n * Creates validator instance.\n * Usage: `Ajv(opts)`\n * @param {Object} opts optional options\n * @return {Object} ajv instance\n */\nfunction Ajv(opts) {\n  if (!(this instanceof Ajv)) return new Ajv(opts);\n  var self = this;\n\n  opts = this._opts = util.copy(opts) || {};\n  this._schemas = {};\n  this._refs = {};\n  this._fragments = {};\n  this._formats = formats(opts.format);\n  this._cache = opts.cache || new Cache;\n  this._loadingSchemas = {};\n  this._compilations = [];\n  this.RULES = rules();\n\n  // this is done on purpose, so that methods are bound to the instance\n  // (without using bind) so that they can be used without the instance\n  this.validate = validate;\n  this.compile = compile;\n  this.addSchema = addSchema;\n  this.addMetaSchema = addMetaSchema;\n  this.validateSchema = validateSchema;\n  this.getSchema = getSchema;\n  this.removeSchema = removeSchema;\n  this.addFormat = addFormat;\n  this.errorsText = errorsText;\n\n  this._addSchema = _addSchema;\n  this._compile = _compile;\n\n  opts.loopRequired = opts.loopRequired || Infinity;\n  if (opts.async || opts.transpile) async.setup(opts);\n  if (opts.beautify === true) opts.beautify = { indent_size: 2 };\n  if (opts.errorDataPath == 'property') opts._errorDataPathProperty = true;\n  this._metaOpts = getMetaSchemaOptions();\n\n  if (opts.formats) addInitialFormats();\n  addDraft4MetaSchema();\n  if (opts.v5) v5.enable(this);\n  if (typeof opts.meta == 'object') addMetaSchema(opts.meta);\n  addInitialSchemas();\n\n\n  /**\n   * Validate data using schema\n   * Schema will be compiled and cached (using serialized JSON as key. [json-stable-stringify](https://github.com/substack/json-stable-stringify) is used to serialize.\n   * @param  {String|Object} schemaKeyRef key, ref or schema object\n   * @param  {Any} data to be validated\n   * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).\n   */\n  function validate(schemaKeyRef, data) {\n    var v;\n    if (typeof schemaKeyRef == 'string') {\n      v = getSchema(schemaKeyRef);\n      if (!v) throw new Error('no schema with key or ref \"' + schemaKeyRef + '\"');\n    } else {\n      var schemaObj = _addSchema(schemaKeyRef);\n      v = schemaObj.validate || _compile(schemaObj);\n    }\n\n    var valid = v(data);\n    if (v.$async === true)\n      return self._opts.async == '*' ? co(valid) : valid;\n    self.errors = v.errors;\n    return valid;\n  }\n\n\n  /**\n   * Create validating function for passed schema.\n   * @param  {Object} schema schema object\n   * @param  {Boolean} _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.\n   * @return {Function} validating function\n   */\n  function compile(schema, _meta) {\n    var schemaObj = _addSchema(schema, undefined, _meta);\n    return schemaObj.validate || _compile(schemaObj);\n  }\n\n\n  /**\n   * Adds schema to the instance.\n   * @param {Object|Array} schema schema or array of schemas. If array is passed, `key` and other parameters will be ignored.\n   * @param {String} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n   * @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.\n   * @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n   */\n  function addSchema(schema, key, _skipValidation, _meta) {\n    if (Array.isArray(schema)){\n      for (var i=0; i<schema.length; i++) addSchema(schema[i], undefined, _skipValidation, _meta);\n      return;\n    }\n    // can key/id have # inside?\n    key = resolve.normalizeId(key || schema.id);\n    checkUnique(key);\n    self._schemas[key] = _addSchema(schema, _skipValidation, _meta, true);\n  }\n\n\n  /**\n   * Add schema that will be used to validate other schemas\n   * options in META_IGNORE_OPTIONS are alway set to false\n   * @param {Object} schema schema object\n   * @param {String} key optional schema key\n   * @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema\n   */\n  function addMetaSchema(schema, key, skipValidation) {\n    addSchema(schema, key, skipValidation, true);\n  }\n\n\n  /**\n   * Validate schema\n   * @param {Object} schema schema to validate\n   * @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid\n   * @return {Boolean} true if schema is valid\n   */\n  function validateSchema(schema, throwOrLogError) {\n    var $schema = schema.$schema || self._opts.defaultMeta || defaultMeta();\n    var currentUriFormat = self._formats.uri;\n    self._formats.uri = typeof currentUriFormat == 'function'\n                        ? SCHEMA_URI_FORMAT_FUNC\n                        : SCHEMA_URI_FORMAT;\n    var valid;\n    try { valid = validate($schema, schema); }\n    finally { self._formats.uri = currentUriFormat; }\n    if (!valid && throwOrLogError) {\n      var message = 'schema is invalid: ' + errorsText();\n      if (self._opts.validateSchema == 'log') console.error(message);\n      else throw new Error(message);\n    }\n    return valid;\n  }\n\n\n  function defaultMeta() {\n    var meta = self._opts.meta;\n    self._opts.defaultMeta = typeof meta == 'object'\n                              ? meta.id || meta\n                              : self._opts.v5\n                                ? v5.META_SCHEMA_ID\n                                : META_SCHEMA_ID;\n    return self._opts.defaultMeta;\n  }\n\n\n  /**\n   * Get compiled schema from the instance by `key` or `ref`.\n   * @param  {String} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).\n   * @return {Function} schema validating function (with property `schema`).\n   */\n  function getSchema(keyRef) {\n    var schemaObj = _getSchemaObj(keyRef);\n    switch (typeof schemaObj) {\n      case 'object': return schemaObj.validate || _compile(schemaObj);\n      case 'string': return getSchema(schemaObj);\n      case 'undefined': return _getSchemaFragment(keyRef);\n    }\n  }\n\n\n  function _getSchemaFragment(ref) {\n    var res = resolve.schema.call(self, { schema: {} }, ref);\n    if (res) {\n      var schema = res.schema\n        , root = res.root\n        , baseId = res.baseId;\n      var v = compileSchema.call(self, schema, root, undefined, baseId);\n      self._fragments[ref] = new SchemaObject({\n        ref: ref,\n        fragment: true,\n        schema: schema,\n        root: root,\n        baseId: baseId,\n        validate: v\n      });\n      return v;\n    }\n  }\n\n\n  function _getSchemaObj(keyRef) {\n    keyRef = resolve.normalizeId(keyRef);\n    return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];\n  }\n\n\n  /**\n   * Remove cached schema(s).\n   * If no parameter is passed all schemas but meta-schemas are removed.\n   * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n   * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n   * @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object\n   */\n  function removeSchema(schemaKeyRef) {\n    if (schemaKeyRef instanceof RegExp) {\n      _removeAllSchemas(self._schemas, schemaKeyRef);\n      _removeAllSchemas(self._refs, schemaKeyRef);\n      return;\n    }\n    switch (typeof schemaKeyRef) {\n      case 'undefined':\n        _removeAllSchemas(self._schemas);\n        _removeAllSchemas(self._refs);\n        self._cache.clear();\n        return;\n      case 'string':\n        var schemaObj = _getSchemaObj(schemaKeyRef);\n        if (schemaObj) self._cache.del(schemaObj.jsonStr);\n        delete self._schemas[schemaKeyRef];\n        delete self._refs[schemaKeyRef];\n        return;\n      case 'object':\n        var jsonStr = stableStringify(schemaKeyRef);\n        self._cache.del(jsonStr);\n        var id = schemaKeyRef.id;\n        if (id) {\n          id = resolve.normalizeId(id);\n          delete self._schemas[id];\n          delete self._refs[id];\n        }\n    }\n  }\n\n\n  function _removeAllSchemas(schemas, regex) {\n    for (var keyRef in schemas) {\n      var schemaObj = schemas[keyRef];\n      if (!schemaObj.meta && (!regex || regex.test(keyRef))) {\n        self._cache.del(schemaObj.jsonStr);\n        delete schemas[keyRef];\n      }\n    }\n  }\n\n\n  function _addSchema(schema, skipValidation, meta, shouldAddSchema) {\n    if (typeof schema != 'object') throw new Error('schema should be object');\n    var jsonStr = stableStringify(schema);\n    var cached = self._cache.get(jsonStr);\n    if (cached) return cached;\n\n    shouldAddSchema = shouldAddSchema || self._opts.addUsedSchema !== false;\n\n    var id = resolve.normalizeId(schema.id);\n    if (id && shouldAddSchema) checkUnique(id);\n\n    var willValidate = self._opts.validateSchema !== false && !skipValidation;\n    var recursiveMeta;\n    if (willValidate && !(recursiveMeta = schema.id && schema.id == schema.$schema))\n      validateSchema(schema, true);\n\n    var localRefs = resolve.ids.call(self, schema);\n\n    var schemaObj = new SchemaObject({\n      id: id,\n      schema: schema,\n      localRefs: localRefs,\n      jsonStr: jsonStr,\n      meta: meta\n    });\n\n    if (id[0] != '#' && shouldAddSchema) self._refs[id] = schemaObj;\n    self._cache.put(jsonStr, schemaObj);\n\n    if (willValidate && recursiveMeta) validateSchema(schema, true);\n\n    return schemaObj;\n  }\n\n\n  function _compile(schemaObj, root) {\n    if (schemaObj.compiling) {\n      schemaObj.validate = callValidate;\n      callValidate.schema = schemaObj.schema;\n      callValidate.errors = null;\n      callValidate.root = root ? root : callValidate;\n      if (schemaObj.schema.$async === true)\n        callValidate.$async = true;\n      return callValidate;\n    }\n    schemaObj.compiling = true;\n\n    var currentOpts;\n    if (schemaObj.meta) {\n      currentOpts = self._opts;\n      self._opts = self._metaOpts;\n    }\n\n    var v;\n    try { v = compileSchema.call(self, schemaObj.schema, root, schemaObj.localRefs); }\n    finally {\n      schemaObj.compiling = false;\n      if (schemaObj.meta) self._opts = currentOpts;\n    }\n\n    schemaObj.validate = v;\n    schemaObj.refs = v.refs;\n    schemaObj.refVal = v.refVal;\n    schemaObj.root = v.root;\n    return v;\n\n\n    function callValidate() {\n      var _validate = schemaObj.validate;\n      var result = _validate.apply(null, arguments);\n      callValidate.errors = _validate.errors;\n      return result;\n    }\n  }\n\n\n  /**\n   * Convert array of error message objects to string\n   * @param  {Array<Object>} errors optional array of validation errors, if not passed errors from the instance are used.\n   * @param  {Object} options optional options with properties `separator` and `dataVar`.\n   * @return {String} human readable string with all errors descriptions\n   */\n  function errorsText(errors, options) {\n    errors = errors || self.errors;\n    if (!errors) return 'No errors';\n    options = options || {};\n    var separator = options.separator === undefined ? ', ' : options.separator;\n    var dataVar = options.dataVar === undefined ? 'data' : options.dataVar;\n\n    var text = '';\n    for (var i=0; i<errors.length; i++) {\n      var e = errors[i];\n      if (e) text += dataVar + e.dataPath + ' ' + e.message + separator;\n    }\n    return text.slice(0, -separator.length);\n  }\n\n\n  /**\n   * Add custom format\n   * @param {String} name format name\n   * @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)\n   */\n  function addFormat(name, format) {\n    if (typeof format == 'string') format = new RegExp(format);\n    self._formats[name] = format;\n  }\n\n\n  function addDraft4MetaSchema() {\n    if (self._opts.meta !== false) {\n      var metaSchema = require('./refs/json-schema-draft-04.json');\n      addMetaSchema(metaSchema, META_SCHEMA_ID, true);\n      self._refs['http://json-schema.org/schema'] = META_SCHEMA_ID;\n    }\n  }\n\n\n  function addInitialSchemas() {\n    var optsSchemas = self._opts.schemas;\n    if (!optsSchemas) return;\n    if (Array.isArray(optsSchemas)) addSchema(optsSchemas);\n    else for (var key in optsSchemas) addSchema(optsSchemas[key], key);\n  }\n\n\n  function addInitialFormats() {\n    for (var name in self._opts.formats) {\n      var format = self._opts.formats[name];\n      addFormat(name, format);\n    }\n  }\n\n\n  function checkUnique(id) {\n    if (self._schemas[id] || self._refs[id])\n      throw new Error('schema with key or id \"' + id + '\" already exists');\n  }\n\n\n  function getMetaSchemaOptions() {\n    var metaOpts = util.copy(self._opts);\n    for (var i=0; i<META_IGNORE_OPTIONS.length; i++)\n      delete metaOpts[META_IGNORE_OPTIONS[i]];\n    return metaOpts;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}